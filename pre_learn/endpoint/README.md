# Endpoint & Basic Socket Operations 学习笔记

这个目录下的 `endpoint.h` 和 `endpoint.cpp` 演示了 Boost.Asio 网络编程中最基础的概念和操作。涵盖了从端点创建、连接建立到同步读写数据的各种方式。

## 核心概念

### 1. 端点 (Endpoint) 与 连接
演示了如何构建网络通信的地址信息。
- **客户端端点**：指定目标 IP 和端口。
- **服务器端点**：指定监听地址（如 `0.0.0.0`）和端口。
- **DNS 解析**：演示了如何通过域名（而非 IP）连接服务器 (`dns_connect_to_end`)。

### 2. 缓冲区 (Buffers)
Boost.Asio 使用特殊的缓冲区对象来传递数据，而不是直接使用裸指针。
- **`const_buffer`**：只读缓冲区，用于发送数据 (`use_const_buffer`)。
- **`mutable_buffer`**：可写缓冲区，用于接收数据 (`use_buffer_str`)。
- **内存管理**：演示了如何使用 `std::string`、`std::vector` 或动态数组 (`new char[]`) 来管理底层内存。
    - *注意*：Asio 的缓冲区只是引用底层内存，必须确保底层内存在异步操作完成前有效。

### 3. 同步写操作 (Synchronous Write)
代码对比了三种发送数据的方式：

| 函数 | 类型 | 特点 | 适用场景 |
| :--- | :--- | :--- | :--- |
| **`socket.write_some`** | 成员函数 | **非原子性**。可能只发送了部分数据就返回。需要手动写循环来保证发送完所有数据。 | 底层控制，或者配合外部循环使用。 |
| **`socket.send`** | 成员函数 | 类似于 `write_some`，但在某些系统上可能提供额外的标志位控制。通常也是阻塞直到发送完成或出错。 | 标准 Socket API 风格。 |
| **`asio::write`** | **自由函数** | **原子性**。内部封装了循环，保证直到所有数据都发送完毕（或出错）才返回。 | **推荐**。最简单安全的方式，防止“半包”发送。 |

### 4. 同步读操作 (Synchronous Read)
代码对比了四种接收数据的方式：

| 函数 | 类型 | 特点 | 适用场景 |
| :--- | :--- | :--- | :--- |
| **`socket.read_some`** | 成员函数 | **非原子性**。只要读到大于 0 字节的数据就立即返回。 | 流式处理，不关心包边界。 |
| **`socket.receive`** | 成员函数 | 类似于 `read_some`。 | 标准 Socket API 风格。 |
| **`asio::read`** | **自由函数** | **原子性**。会一直阻塞直到填满提供的缓冲区（或出错）。 | 读取定长消息（如消息头）。 |
| **`asio::read_until`** | **自由函数** | 读取直到遇到指定的分隔符（如 `\n`）。通常配合 `asio::streambuf` 使用。 | 文本协议（如 HTTP, Telnet）。 |

## 学习建议
1.  **区分 `_some` 后缀函数与自由函数**：这是初学者最容易犯错的地方。`write_some` 不保证写完，`read_some` 不保证读满。在业务逻辑中，通常推荐使用 `asio::write` 和 `asio::read` (或 `asio::read_until`) 来简化逻辑。
2.  **缓冲区生命周期**：虽然这里演示的是同步操作（阻塞直到完成），但在异步编程中，必须格外注意缓冲区的生命周期问题（参考 `Session` 目录下的 `MsgNode`）。

---
*注：本示例主要演示同步 (Synchronous) 操作，即函数调用会阻塞线程直到网络操作完成。*

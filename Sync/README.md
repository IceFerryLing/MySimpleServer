# Synchronous TCP Client & Server 学习笔记

这个目录包含了基于 Boost.Asio 的同步 (Synchronous) TCP 客户端和服务器实现。同步模式意味着网络操作（如连接、读写）会阻塞当前线程，直到操作完成或发生错误。

## 文件说明

*   **`SyncServer.cpp`**: 同步 TCP 回显 (Echo) 服务器。采用 "Thread-per-Connection"（每连接一个线程）模型。
*   **`SyncClient.cpp`**: 同步 TCP 客户端。连接服务器，发送消息并接收回显。
*   **`*学习版.cpp`**: 带有详细中文注释的代码版本，适合初学者阅读，解释了每一行代码的作用和设计意图。

## 核心架构

### 1. 服务器 (SyncServer)
服务器采用了经典的 **多线程并发模型**：
1.  **主线程**：运行 `acceptor.accept()`，阻塞等待新的客户端连接。
2.  **工作线程**：一旦有新连接，主线程创建一个新的 `std::thread`，并将新生成的 `socket` 移交给该线程。
3.  **分离运行**：使用 `thread.detach()` 让工作线程在后台独立运行，主线程立即返回继续等待下一个连接。

*   **优点**：逻辑简单，易于理解和实现。
*   **缺点**：线程资源昂贵。当并发连接数很高（如成千上万）时，创建大量线程会消耗大量内存和 CPU 上下文切换开销，不适合高并发场景。

### 2. 客户端 (SyncClient)
客户端展示了标准的同步调用流程：
1.  **Winsock 初始化** (Windows 特有)：调用 `WSAStartup`。
2.  **连接**：`socket.connect()` 阻塞直到三次握手完成。
3.  **发送**：`asio::write()` 阻塞直到数据全部写入发送缓冲区。
4.  **接收**：`asio::read()` 阻塞直到读取到指定长度的数据。

## 关键代码解析

### Windows 环境注意事项
在 `SyncClient.cpp` 中，你会看到如下代码：
```cpp
#include <winsock2.h>
// ...
WSAStartup(MAKEWORD(2, 2), &wsaData);
// ...
WSACleanup();
```
这是 Windows 平台使用 Socket API 的硬性要求。虽然 Boost.Asio 内部通常会自动处理这些初始化，但在某些特定场景或为了明确展示底层依赖时，显式调用也是一种学习方式。

### 读写函数的选择
*   **`read_some` (Server端使用)**：服务器不知道客户端会发多少数据，所以使用 `read_some` 读取任意可用的数据，适合流式处理。
*   **`asio::read` / `asio::write` (Client端使用)**：客户端知道自己要发多少，也知道服务器会回显多少，所以使用自由函数版本，保证读写完整的指定长度。

## 运行步骤

1.  编译并运行 `SyncServer.exe`。它会监听 `10086` 端口。
2.  编译并运行 `SyncClient.exe`。
3.  在客户端控制台输入一段文本并回车。
4.  观察服务器收到消息，客户端收到回显消息。

## 思考题
*   如果客户端发送的数据长度超过了服务器 `read_some` 的缓冲区大小 (1024)，会发生什么？
*   如果去掉 `t->detach()`，服务器还能同时处理多个客户端吗？（答案：不能，如果不 detach 且不 join，线程对象析构时会崩溃；如果 join，则会变成串行处理）。
